\chapter{Data Abstraction}

In this chapter I discuss the design of data structure and clustering technique used to support the visual requirement. First, an overview of the input data generated from the game will be explained. Then a description on how this data is extracted to be the input of the visualization interface will be given. Finally, a clustering algorithm selected to be used in the visualization will be discussed.

\section{Game Events Structure}
\subsection{Event Category}
The goal of Hammer and Planks game is to kill all of the enemies while avoiding any attack from the enemies and obstacles\cite{diloreto}. Along the way, player can also catch bonuses to increase their score. Based on these, I identify three different objects within the game: Enemy, Bonus, and Obstacle. For each of these object, there are certain events associated. Each event which happened during the gameplay is recorded in the log file with the following information: event type, timestamp, object id, and location. In total, there are 8 event types:
\newcommand{\events}[2]{$#1 _ #2$}	
\begin{enumerate}[label=({\arabic*})]
\item Catch: when a bonus is catched
\item Miss: when a bonus is missed or player's attack on enemy is missed
\item Dodge: when an obstacle is avoided
\item Collision: when the player's boat collide with an enemy or obstacle
\item Kill: when an enemy is destroyed by player's boat
\item Hit: when the player's attack hit an enemy
\item Hurt: when the enemy's attack hit player's boat
\item Miss: when the enemy's attack missed player's boat
\end{enumerate}

Based on the level of impact of each event to the user's boat, we characterize the event by assign it with Positive, Neutral, or Negative as shown in the following table:
\begin{table}[h]
\begin{center}
    \begin{tabular}{| l | l | l | l |}
    \hline
    Events & Bonus & Obstacle & Enemy \\ \hline
    Positive & catch & - & kill,hit\\ \hline
    Neutral & miss & dodge & miss\\ \hline
    Negative & - & collision & hurt, collision\\
    \hline
    \end{tabular}
    \caption {Event Type grouping}
\end{center}
\end{table}

\subsection{Game World Coordinates}
Each object and event in the game are assigned with 3D location coordinates. An \textit{x} axis of this coordinate indicate horizontal axis of the screen. However, \textit{y} axis indicate vertical axis in the game world which means -\textit{y} is a location under the sea and +\textit{y} is above the sea. \textit{z} axis indicate vertical axis of the screen. The visualization uses the x axis to represent body movement over horizontal axis and z axis to calculate screen speed as explain in the following sub section.

\subsection{Screen Speed}
In the game, a big number of positive events indicate a good player's performance. However, it is important to consider whether the events happened when the player's boat move fast or slowly \ref{t14}\ref{t16}. Getting all the bonuses while moving fast requires precise hand/body movement which indicates improvement in rehabilitation process. Boat speed while navigating the sea is basically the speed in which the screen scroll($\upsilon_{scr}$). This is calculated by identifying the location(apparition z coordinate $\theta_{apr}$) and time (apparition time $\textit{t}_{apr}$) of an object when it first appear on the screen, and location(event z coordinate $\theta_{evt}$) and time(event time $\textit{t}_{evt}$) when an event happened on that object.

$$ \upsilon_{scr} = \frac{\theta_{evt}-\theta_{apr}}{\textit{t}_{evt}-\textit{t}_{apr}} $$

\section{Clustering Algorithm}

In understanding the common evolution of the gameplay among different sessions over x-area, it is interesting to see what the common evolution of different section of x-area\ref{t27}. The idea is to aggregate similar distribution of movements (which is represented by events in the game) so that consecutive section which has similar evolution is represented by a single representation. To achieve this, a clustering algorithm based on hierarchical clustering is introduced(see Algorithm \ref{alg:Clustering}). 
\begin{algorithm}
  \caption{Hierarchical Clustering}\label{alg:Clustering}
  \begin{algorithmic}[1]
  \STATE Divide the x-area into slices the size of minimum x axis unit.
  \STATE Define the profile for each section. Let a section be Slice $\textit{S}_i$, number of session be $n_{ses}$ and number of section be $n_{sec}$. An $\textit{S}_i$ is an ordered set of triplet $\textit{t}_i$. Each triplet represents dataset of a certain game session of a particular Slice. The triplet consists of the number of negative, neutral and positive events.
$$\textit{t}_i = (n_{neg}, n_{net}, n_{pos})$$
$$\textit{S}_i = \{\textit{t}_i(1), \textit{t}_i(2), ..., \textit{t}_i(n_{ses})\}, 1\le i\le n_{sec}$$
  \STATE Calculate the distance between slice $\textit{S}_i$ and $\textit{S}_{i+1}$ (explained in Distance Calculation).
  \STATE Following the Hierarchical Clustering algorithm\cite{maimon}, merge two consecutive slices if it satisfies the distance threshold specified. Calculate the distance of the merged slices with the next slice and merge them if the distance is still below the threshold. Repeat the process until there is no distance which satisfies the threshold.


  \end{algorithmic}
\end{algorithm}\newline 

\textbf{Distance Calculation}\newline 
Since the idea was to aggregate consecutive sections with similar movement pattern, there are two types of distance considered: (i)how different both sections in term of event types proportion within each section (ii)how different both sections in term of the evolution of each event type throughout the sessions. Thus, for each pair of consecutive sequences ($\textit{s}_1$,$\textit{s}_2$) of \textit{S}, distance is defined as:
$$d(\textit{s}_1,\textit{s}_2) = \alpha\textit{f}(\textit{s}_1,\textit{s}_2) + (1 - \alpha)\textit{g}(\textit{s}_1,\textit{s}_2)$$
$$\text{where } \textit{g}(\textit{s}_1,\textit{s}_2) = \frac{\textit{g}_1(\textit{s}_1,\textit{s}_2) + \textit{g}_2(\textit{s}_1,\textit{s}_2) + \textit{g}_3(\textit{s}_1,\textit{s}_2)}{3}$$

\[\text{and for } i  \in \{0,1,2\}\text{, } g_i(\textit{s}_1,\textit{s}_2) = \left\{
  \begin{array}{ll}
    0 & \text{ if } \textit{s}\lbrack j \rbrack\lbrack i \rbrack=0 \text{ for each } 0 \leqslant j < |\textit{s}|\text{, } \textit{s} \in \{\textit{s}_1,\textit{s}_2\}\\
    1 & \text{ if } \textit{s}_k\lbrack j \rbrack\lbrack i \rbrack=0 \text{ for each } 0 \leqslant j < |\textit{s}_k| \text{ and } \exists \textit{s}_p\lbrack j \rbrack\lbrack i \rbrack \neq 0\\
      & \text{ and } k \in \{1,2\} \text{, } p \in \{1,2\} \text{, } k \neq p\\
	\frac{\sqrt{\displaystyle\sum_{k=0}^{\lvert\textit{s}_1\lvert} (\textit{s}_1'\lbrack k \rbrack\lbrack i \rbrack - \textit{s}_2'\lbrack k \rbrack\lbrack i \rbrack)^2}}{\sqrt{\lvert\textit{s}_1\rvert}}
  \end{array}
\right.
\]

$$ d(\textit{S}_i,\textit{S}_{i+1}) = \displaystyle\sum_{j=1}^{n_{ses}} ED(\textit{t}_i (j), \textit{t}_{i+1} (j))$$


